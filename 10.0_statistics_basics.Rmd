# A primer in statistics"

```{r, include=FALSE}
options(tinytex.verbose = TRUE)
```

Based on the very helpful revision chapter in [Modern Statistics for the Life Sciences, Alen Grafen and Rosie Hails, OUP](https://global.oup.com/ukhe/product/modern-statistics-for-the-life-sciences-9780199252312?cc=gb&lang=en&).

```{r global-options, include=FALSE,echo=FALSE}
knitr::opts_chunk$set(fig.width=9,
                      fig.height=5,
                      fig.align='center',
                      warning=FALSE,
                      message=FALSE,
                      echo=FALSE)
```

```{r load packages, message=FALSE,warning=FALSE}
library(tidyverse)
library(here)
library(kableExtra)
library(cowplot)
library(gridExtra)

set.seed=232342
```

```{r}
# we use the fabulous openintro here only for its colour scheme
library(openintro)
data(COL)
fill_colour1<-COL['blue','f3']
fill_colour2<-COL['red','f6']
line_colour<-COL['blue','full']
func_colour<-"darkblue"
point_colour<-COL['blue','full']
error_colour<-COL['red','full']
```

```{r}
# bespoke themes to set axis styles. Minl
theme_no_x <- function () { 
    theme_cowplot() %+replace% 
  theme(
    axis.ticks.x=element_blank(),
    axis.text.x=element_blank(),
    axis.title.x=element_blank(),
    axis.line.x=element_blank()
        )
}

theme_no_y <- function () { 
    theme_cowplot() %+replace% 
  theme(
    axis.ticks.y=element_blank(),
    axis.text.y=element_blank(),
    axis.title.y=element_blank(),
    axis.line.y=element_blank()
        )
}

theme_no_axes <- function () { 
    theme_cowplot() %+replace% 
  theme(
    axis.ticks=element_blank(),
    axis.text=element_blank(),
    axis.title=element_blank(),
    axis.line=element_blank()
        )
}
```



### Populations and samples

It is rarely possible to get an exact answer to a question. Normally we have to make do with an estimate, and this may vary from a rough estimate to a more precise one. 

One of the first tasks of statistics to state this in more precise terms. 

Suppose, for example, we wanted to know the average height of adult women between the ages of 25 and 35 in the United Kingdom. It is quite impossible to measure the height of every single woman of that age. Instead we must content ourselves with taking a sample, finding the average height of women within that and hoping that it is representative of the whole population.

A __sample__ is a __random__ selection from within a __population__. For this to be the case the population needs to be precisely defined, since our sampling strategy will depend on this.

Having taken our sample we compute the mean by summing and dividing by the number of values:

//
\bar{y}=\frac{\Sigma y_i}{n}
//

This is our estimate of the true population mean, $\mu$. It is similar when we do an experiment. Measurements in an experiment inevitably involve error, and so we can think of the data readings we actually take as being a sample from the population of all the readings that could have occurred. The mean value that we get at the end from our data is thus an estimate of the true mean $\mu_\text{A}$, which we would only have obtained if there was no error involved in the experiment.

### Three types of variability: of the sample, of the population and of the estimate.

#### Variability of the sample

As well as the mean, we would like to know how variable our sample is. This gives us an idea as to how precise our estimate of the population mean is. Is it a rough one, or a precise one? 

Two samples can have the same mean but very different variabilities. For example if the results for a class of _n_=30 students for a test in maths ranged from 40 to 70 while those for a test in English ranged from 50 to 60, then both might have a mean of 55, but, clearly, results in maths would be more variable than those in English.

For any individual score in either test, we can calculate its __deviation__ from the mean of the score for that test, where

$$
\text{deviation} = \text{datapoint} - \text{mean}
$$
If we sum the deviations of the scores from each test from their respective means, we would find that the absolute value of these deviations tend to be bigger for the maths test than for the English test. For both tests, however, the sum of the deviations would be zero, because of the definition of the mean as the central point, but if the deviations are squared and summed, we then get a measure of the variability of each dataset around its mean.

```{r,echo=FALSE}
maths_scores<-c(rep(40,1),rep(44,3),rep(48,7),rep(52,3),rep(55,3),rep(56,3),rep(60,2),rep(64,3),rep(68,4),rep(72,1))
english_scores<-c(rep(46,2),rep(49,2),rep(52,9),rep(55,0),rep(56,7),rep(57,5),rep(60,0),rep(62,4),rep(64,0),rep(65,1))

scores<-tibble(score=c(maths_scores,english_scores),subject=c(rep("maths",30),rep("english",30)))

scores %>%
  ggplot(aes(x=score)) +
  geom_histogram(binwidth=4,fill=fill_colour1,colour=line_colour) +
  scale_x_continuous(breaks=seq(40,72,4),labels=seq(40,72,4)) +
  scale_y_continuous(limits=c(0,12),breaks=seq(0,12,2)) +
  labs(x="Scores",
       y="Frequency",
       title="Two distributions with the same mean of 55") +
  facet_wrap(~subject,ncol=2,labeller = labeller(subject=c("english"="English","maths"="maths"))) +
  theme_cowplot()
```

```{r,echo=FALSE,fig.height=3}
ss_english=sum((english_scores-mean(english_scores))^2)
ss_maths=sum((maths_scores-mean(maths_scores))^2)

caption="Two datasets of size $n=30$ with the same mean but different variability"
col_names<-c("","$\\bar{y}$","","","$s^2$","$s=\\sqrt{s^2}$")

var_tbl<-tibble(
  Scores=c("English scores","maths scores"),
  Mean=c("$\\frac{1}{n}\\Sigma y_i=55$","$\\frac{1}{n}\\Sigma y_i=55$"),
  sumdev=c("$\\Sigma \\left(y_i-\\bar{y}\\right)=0$","$\\Sigma \\left(y_i-\\bar{y}\\right)=0$"),
  Variability=c("$\\Sigma (y_i-\\bar{y})^2=638$","$\\Sigma (y_i-\\bar{y})^2=2219$"),
  variance=c("$\\frac{1}{n-1}\\Sigma (y_i-\\bar{y})^2=\\frac{638}{29}=22.0$","$\\frac{1}{n-1}\\Sigma (y_i-\\bar{y})^2=\\frac{2219}{29}=76.5$"),
  st_dev=c("$\\sqrt{22.0}=4.7$","$\\sqrt{76.5}=8.75$")
) %>%
  kbl(align="c",booktabs=TRUE, escape= FALSE,col.names=col_names) %>%
  add_header_above(c("Scores","Mean","Sum of deviations","Sum of squared deviations","Variance","Standard deviation"),align="c") %>%
  kable_styling()
var_tbl
```

In this case, a comparison of the sums of squares is valid, since the two datasets have the same size. In general though, a larger dataset will have a larger sum of squares, so for a valid comparison between unequally sized datasets, a measure that is independent of the size of the dataset is required.

To get this, all we need to do is take account of the sample size. We used _n_ data points to define the mean, then the same _n_ datapoints, plus the mean itself, to define the variability around the mean. But from the way in which the mean is calculated, the deviations must sum to zero. This means that we have only _n_-1 independent pieces of information about how the sample varies around the mean. Hence, our final measure of the variability of a data set, which we call the __variance__ and denote as $s^2$, is found by dividing the sum of squared deviations by _n_-1, not by _n_.

$$
s^2=\frac{\Sigma{\left(y_i-\bar{y}\right)^2}}{n-1}
$$

The number of independent pieces of information that contribute to the calculation of a statistic is called the __degrees of freedom__.

Often, we would like a measure of variability that has the same units as the data itself. The variance does not, but we remedy that by taking its square root to find the __standard deviation__ $s$ of the dataset.

#### Variability of the population

Just as we cannot know the true mean $\mu$ of a population, but can only estimate it from the mean $\bar{y}$ of a sample that we draw from that population, so we cannot know the true variance of a population. Nevertheless, it is useful to define it, and it is frequently referred to as $\sigma^2$  ("sigma squared"). Our best estimate of it is our sample variance $s^2$. 

A definition of it is that it is the expected squared deviation around the true mean for all individuals in the population.

#### Variability of the estimate

Having obtained our estimate $\bar{y}$ of the true mean $\mu$ of a population, we would like to know how accurate it is. To answer this we will briefly discuss  __Normal distributions__.

##### The Standard Normal Distribution

Many continuous attributes (eg weight, height, width) of a population are scattered around a mean value in such way that, if you plotted a histogram of the values, it would have a shape that is approximately bell-shaped and symmetric and well described by a Normal distribution (the reasons for this are interesting, but beyond the scope of this document). Such a distribution is described by two parameters - its mean (middle value) and its variance (spread).  A __standard normal__ distribution is simply a normal distribution with a mean of 0 and a variance (and therefore a standard deviation, which is the square root of the variance) of 1. Such a distribution is sometimes referred to as a $Z$ distribution.


Any normal distribution can be converted to a standard normal distribution by doing two things. Suppose a variable $Y$ follows a normal distribution, with mean 5 and standard deviation 2. First we subtract the mean from every value. This will have the effect of moving the whole distribution leftwards on the _x_-axis by 5 units, the mean value of _Y_, so that it is centred on 0. Then, we divide each value by 2, the standard deviation of _Y_. This will have the effect of squishing the distribution inwards, giving it a new standard deviation of 1. The result will be a standard normal, centred at 0, with standard deviation 1. The process of carrying out these two operations is known as __standardising__.

```{r,echo=FALSE}
### Plots to illustrate the standardisation of a normal distribution
xvals<-seq(-13,13,0.1)
y0<-dnorm(xvals,mean=5,sd=2)
y1<-dnorm(xvals,mean=0,sd=2)
y2<-dnorm(xvals,mean=0,sd=1)

g1<-data.frame(x=xvals,y=y0) %>%
  filter(x>-3 & x<13) %>%
  ggplot(aes(x=x,y=y)) +
  geom_line(colour=func_colour) +
  #labs(title="Example of standardising a normal distribution") +
  scale_x_continuous(limits=c(-8,13),breaks=seq(1,9,2),labels=c("1","3","5","7","9")) +
  ylim(0,0.2) +
  geom_segment(x=1,y=0,xend=1,yend=dnorm(1,5,2),linetype="dashed",colour="darkred") +
  geom_segment(x=5,y=0,xend=5,yend=dnorm(5,5,2),linetype="dashed",colour="darkred") +
  geom_segment(x=9,y=0,xend=9,yend=dnorm(9,5,2),linetype="dashed",colour="darkred") +
  annotate("text", x=-2., y = 0.8*dnorm(5,5,2), label = "The original distribution...") +
  annotate("text", x=-2., y = 0.6*dnorm(5,5,2), label = "Mean = 5") +
  annotate("text", x=-2., y = 0.45*dnorm(5,5,2), label = "Standard deviation = 2") +
  theme_cowplot() +
  theme_no_y() +
  theme(axis.title.x=element_blank())
  # theme(axis.line.y = element_blank(),
  #       axis.title = element_blank(),
  #       axis.text.y = element_blank(),
  #       axis.ticks.y = element_blank())


g2<-data.frame(x=xvals,y=y1) %>%
  filter(x>-8 & x<8) %>%
  ggplot(aes(x=x,y=y)) +
  geom_line(colour=func_colour) +
  scale_x_continuous(limits=c(-8,13),breaks=seq(-4,4,2),labels=c("-4","-2","0","2","4")) +
  ylim(0,0.2) +
  geom_segment(x=-4,y=0,xend=-4,yend=dnorm(-4,0,2),linetype="dashed",colour="darkred") +
  geom_segment(x=0,y=0,xend=0,yend=dnorm(0,0,2),linetype="dashed",colour="darkred") +
  geom_segment(x=4,y=0,xend=4,yend=dnorm(4,0,2),linetype="dashed",colour="darkred") +
  annotate("text", x= 6, y = 0.8*dnorm(0,0,2), label = "Subtract 5 from every value...") +
  theme_cowplot() +
  theme_no_y() +
  theme(axis.title.x=element_blank())


g3<-data.frame(x=xvals,y=y2) %>%
  filter(x>-4 & x<4) %>%
  ggplot(aes(x=x,y=y)) +
  geom_line(colour=func_colour) +
  scale_x_continuous(limits=c(-8,13),breaks=seq(-2,2,1),labels=c("-2","-1","0","1","2")) +
  geom_segment(x=-2,y=0,xend=-2,yend=dnorm(-2,0,1),linetype="dashed",colour="darkred") +
  geom_segment(x=0,y=0,xend=0,yend=dnorm(0,0,1),linetype="dashed",colour="darkred") +
  geom_segment(x=2,y=0,xend=2,yend=dnorm(2,0,1),linetype="dashed",colour="darkred") +
  annotate("text", x= 6, y = 0.8*dnorm(0,0,1), label = "...then divide every value by 2.") +
  annotate("text", x= 6, y = 0.55*dnorm(0,0,1), label = "This gives us a Standard Normal.") +
  theme_cowplot() +
  theme_no_y() +
  theme(axis.title.x=element_blank())

grid.arrange(g1,g2,g3)
```

In summary, in order to convert a variable _Y_ that is normally distributed with mean $\mu$ and standard deviation $\sigma$, to a standard normal _z_, we subtract the mean then divide by the standard deviation:

$$
z=\frac{Y-\mu}{\sigma}
$$

Why would we want to do this? The answer is that the standard normal is an example of a __probability density function__ (or _pdf_ for short). Such functions have particular properties that are useful to us as scientists. In particular, it is straightforward to calculate what proportion of any set of observations described by a pdf fall within or beyond a certain number of standard deviations of the mean. 

The total area under a standard normal, as for any pdf, is 1, since it is a certainty that the random variable it describes takes some value or other.

The area under it to the right of zero and the area under it to the left of zero are both 0.5, since the distribution is symmetric about zero. This tells you that if you had a random variable that was described by a standard normal, then there would be a 50% chance that it was positive, and a 50% chance that it was negative. In general, if you take a random individual from a population and measure the value of some attribute (such as its height) that is well described by a normal distribution, then there would be a 50% chance that the value for this individual is less than the population mean, and a 50% chance that it is greater.

The area under the distribution beyond a distance roughly two standard deviations (actually, 1.96) either side of the mean totals 0.05, or 5% of the total area under the curve. This means that if, again, we have a population for which some attribute is well described by a normal distribution, then roughly 95% of individuals will have a value of that attribute that falls within two standard deviations of the mean, and roughly 5% of them will fall beyond that. Or, put another way, if you took a random individual from the population, there is a 95% chance that its value for this attribute would be within about 2 standard deviations of the mean, and a 5% chance that it would be more than about 2 standard deviations greater or less than the mean.

```{r,fig.height=3,fig.width=10}
# graphics to illustrate some standard normals

z_critical_95 <- qnorm(0.975)
#z_critical_df_25 <- qt(0.95, df = 25)

nd_base<-ggplot(NULL, ) +
  stat_function(fun = dnorm,
                geom = "line",
                xlim = c(-4, 4),
                colour=line_colour) +
  labs(x="x") +
  theme_cowplot() +
  theme_no_y()

p_all<-nd_base + 
  stat_function(fun = dnorm,
                geom = "area",
                fill = fill_colour1,
                xlim = c(-4, 4)) +
  annotate("text", x= 0, y = 0.2*dnorm(0,0,1), label = "Total area = 1")

p50<- nd_base +
  stat_function(fun = dnorm,
                geom = "area",
                fill = fill_colour2,
                xlim = c(-4, 0)) +
  stat_function(fun = dnorm,
                geom = "area",
                fill = fill_colour1,
                xlim = c(0, 4)) +
  geom_segment(aes(x=0,y=0,xend=0,yend=dnorm(0)),
               linetype="dashed",colour=line_colour) +
  annotate("text", x= -1, y = 0.11*dnorm(0,0,1), label = "Area =\n 0.5",size=3.) +
  annotate("text", x= 1, y = 0.11*dnorm(0,0,1), label = "Area =\n 0.5",size=3.)
  
p95<-nd_base +  
  stat_function(fun = dnorm,
                geom = "area",
                fill = fill_colour1,
                xlim = c(z_critical_95, 4)) +
  stat_function(fun = dnorm,
                geom = "area",
                fill = fill_colour1,
                xlim = c(-4,-z_critical_95)) +
  stat_function(fun = dnorm,
                geom = "area",
                fill = fill_colour2,
                xlim = c(-z_critical_95,z_critical_95)) +
  geom_segment(aes(x=0,y=0,xend=0,yend=1.0*dnorm(0)),
               linetype="dashed",colour=line_colour) +
  geom_segment(aes(x=-z_critical_95,y=0,xend=-z_critical_95,yend=1.0*dnorm(0)),
               linetype="dashed",colour=line_colour) +
  geom_segment(aes(x=z_critical_95,y=0,xend=z_critical_95,yend=1.0*dnorm(0)),
               linetype="dashed",colour=line_colour) +
  annotate("text", x= 0, y = 0.1*dnorm(0), label = "95% of area",size=3.) +
  annotate("text", x= -3.2, y = 0.11*dnorm(0), label = "2.5% of\n area",size=3) +
  annotate("text", x= 3.2, y = 0.11*dnorm(0), label = "2.5% of\n area",size=3) +
  
  
  
  geom_text(aes(label = "mu-1.96*sigma", x = -z_critical_95, y = 1.05*dnorm(0)), size = 3, colour = "darkred",parse=TRUE) +
  geom_text(aes(label = "mu+1.96*sigma", x = z_critical_95, y = 1.05*dnorm(0)), size = 3, colour = "darkred",parse=TRUE) +
  geom_text(aes(label = "mu", x = 0, y = 1.05*dnorm(0)), size = 3, colour = "darkred",parse=TRUE)



grid.arrange(p_all,p50,p95,nrow=1)

```


Of particular practical importance, if a dataset is normally distributed, then about 68% of the observations fall with one standard deviation of the mean, 95% fall within 1.96 standard deviations, about 96% fall with two standard deviations, and about 99.7% (ie practically all of them) fall within three standard deviations. The plot below illustrates this.

```{r,fig.height=3,fig.width-10}
# Plot to illustrate general properties of a normal distribution
set.seed(12345)
N=100
mu=8
st.dev=2
binwidth=1
x_breaks<-c(mu)
x_labels<-c("\u00b5")

p_base<-ggplot(data.frame(x = rnorm(N,mean=mu,sd=st.dev)), aes(x)) +
  scale_x_continuous(limits=c(mu-4*st.dev,mu+4*st.dev),breaks=x_breaks,labels=x_labels) +
  geom_function(fun = dnorm, args = list(mean = mu, sd = st.dev),colour=line_colour) +
  theme_cowplot() +
  theme_no_y() +
  theme(axis.title.x=element_blank())
 

pplot<-function(base_plot,mu,sigma,n_sigma){
  if(n_sigma==1){
    mult=""
  } else {
    mult=paste0(n_sigma,"*")
  }
  
  gap=pnorm(n_sigma)-pnorm(-n_sigma)
  digits=ifelse(gap>0.99,3,2)
  gap=paste0(100*round(gap,digits),"%")
  
  p_out<-base_plot +
  annotate("text",label=paste0("mu %+-%",mult,"sigma"),x=mu,y=0.25,parse=TRUE) +
  geom_segment(x=mu-n_sigma*st.dev,y=0,xend=mu-n_sigma*st.dev,yend=0.2,linetype="dashed",colour="grey60") +
  geom_segment(x=mu+n_sigma*st.dev,y=0,xend=mu+n_sigma*st.dev,yend=0.2,linetype="dashed",colour="grey60") +
  geom_segment(aes(x = mu+n_sigma*st.dev, y = 0.05, xend = mu-n_sigma*st.dev, yend = 0.05),
                  arrow = arrow(length = unit(0.2, "cm"),end="both",type="closed"),colour="grey60") +
  geom_text(aes(label = gap, x = mu, y = 0.057), size = 4, colour = "darkred",nudge_y = 0.0025,parse=FALSE) + 
  annotate("text",label=paste0("mu-",mult,"sigma"),x=mu-n_sigma*st.dev,y = 0.21,size = 4, colour = "darkred",parse=TRUE) +
  annotate("text",label=paste0("mu+",mult,"sigma"),x=mu+n_sigma*st.dev,y = 0.21,size = 4, colour = "darkred",parse=TRUE) +
  stat_function(fun = dnorm, args=list(mean=mu,sd=st.dev),
                geom = "area",
                fill = fill_colour1,
                xlim = c(mu-n_sigma*st.dev,mu+n_sigma*st.dev)) +
  theme(plot.subtitle = element_text(hjust = 0.5))
  p_out
}

p1<-pplot(p_base,mu,st.dev,1)
p2<-pplot(p_base,mu,st.dev,1.96)
p3<-pplot(p_base,mu,st.dev,3)
grid.arrange(p1,p2,p3,nrow=1)
  
```

So much for an ideal normal distribution. A real data set drawn from a population that is approximately normally distributed would have some scatter, the more so the smaller the size of the sample. For such a sample we would find that _approximately_ two thirds of the data set is within one standard deviation of the mean, 95% are within _approximately_ two standard deviations and pretty much all of them are within three standard deviations.


##### Accuracy of the estimate

We are interested in the population. We want to know its true mean $\mu$, but what we have as our best estimate of this is the mean $\bar{y}$ of a sample of size _n_ that we drew from the population. If we took another sample from the population of the same size, we would get a different sample mean, and so on again and again, if we had the time and resources to repeatedly take sample after sample. So our sample mean is itself a random variable $\bar{Y}$, drawn from a population of all possible sample means. If we drew samples of the same size _n_ many times from our population of interest, the means $\bar{y}$ of these samples would themselves form a distribution, the so-called __sampling distribution__, and the mean of _this_ we would hope, would be the true mean $\mu$ of the population.

The bigger the variance $\sigma^2$ of the population, the more we would expect our estimate to differ from the true mean, and the less variable the population was, the closer we would expect our estimate to be to the true mean. Similarly, if we took a large sample then our estimate is likely to be closer to the true mean than if we took a small sample.

If we take these observations together, what we find is that the variance of the distribution of our estimates is $\sigma^2/n$, and so the standard deviation of our estimate is the square root of this ie $\frac{\sigma}{\sqrt{n}}$. This is sometimes called the __standard error of the mean__. This gives us an idea of how precise our sample mean is as an estimate of the true mean.

#### Example

```{r}
population_size<-10000
sample_size<-100
n_samples<-200
mu<-145
sigma<-15
lower_xlim<-mu-4*sigma
upper_xlim<-mu+4*sigma
seal.population<-tibble(mass=rnorm(population_size,mu,sigma)) %>%
  filter(mass<=upper_xlim & mass>lower_xlim)
```

Suppose the  population of grey seals around the coast of south west England includes 10,000 adult females, whose weights are normally distributed and in the range 100 - 190 kg. Let this be our 'population of interest'. The weights of individuals in this population are approximately normally distributed with a mean value of 145 kg, and a standard deviation of 15 kg.

_Note that in reality we would not know the mean or standard deviation of this population, or how many seals there were in total or whether the weights of adult females within it were normally distributed (or distributed any other way)._

A histogram of the weights of the entire population would look something like this:




```{r}
myfun<-function(x,mean,sd,N,binwidth){
  N*binwidth*dnorm(x,mean=mean,sd=sd)
}
```

```{r,out.width="70%"}
population_dist<-
  seal.population %>%
  ggplot(aes(x=mass)) +
  geom_histogram(binwidth=5,fill=fill_colour1,colour=line_colour) +
  geom_function(fun=myfun,args=list(mean=mu,sd=sigma,N=population_size,binwidth=5),colour=func_colour) +
  scale_x_continuous(limits=c(lower_xlim,upper_xlim)) +
  labs(x='Weight(kg)',
       y='Frequency',
       subtitle="Population distribution") +
  theme_cowplot() +
  theme_no_y() +
  theme(plot.subtitle = element_text(hjust=0.5))
population_dist +
  geom_vline(xintercept=mu,colour="darkred",linetype="dashed")
```

Suppose we wanted to know the mean and standard deviation of the weights of adult female grey seals in this population. Clearly, we could not find the true value since that would require weighing every seal in the population, which is impossible, but we could estimate the values by weighing all seals in a manageable sample that we hope is representative of the whole population. Suppose our sample were 100 randomly chosen adult female seals. 

In reality, that would probably be the only sample we could get, and so our estimates $\bar{y}$ and _s_  of the true mean $\mu$ and true standard deviation $\sigma$ respectively would be based entirely on that one sample.

To get an idea of how accurate our estimate is, imagine we could measure such samples of 100 seals randomly selected from the population many, many times over. Each sample would have a slightly different mean. Let us plot the distribution of some of those samples and superpose on top of them the 'normal distribution' curve that we know is a good representation of the weights of adult females in the whole population. (We know this because this is a simulation. In truth, we wouldn't.) For each sample, we display its mean $\bar{y}$ and standard deviation _s_.

```{r}
set.seed(2323)
samples <-  as_tibble(
  replicate(n=n_samples,expr=sample(seal.population$mass,size=sample_size,replace=TRUE))
  )

sample_names<-rep("",n_samples)
for(i in 1:n_samples){
  sample_names[i]<-str_c("Sample",i,sep="_")
}
colnames(samples)<-sample_names
sample_means<-tibble(means=colMeans(samples))
```

```{r}
single_sample<-tibble(mass=sample(seal.population$mass,size=sample_size,replace=TRUE))
single_sample_dist<-
  single_sample %>%
  ggplot(aes(x=mass)) +
  geom_histogram(binwidth=5,fill=fill_colour1,colour=line_colour) +
  geom_function(fun=myfun,args=list(mean=mu,sd=sigma,N=sample_size,binwidth=5),colour=func_colour) +
  scale_x_continuous(limits=c(lower_xlim,upper_xlim)) +
  labs(x='Weight(kg)',
       y='Frequency',
       subtitle="Single sample distribution") +
  annotate("text",
           x=87,y=16,
           hjust=0,
           vjust=1,
           label="This is about the same\nwidth as the population\ndistribution ",
           size=2.5,
           colour="darkred") +
  annotate("text",
           x=170,y=16,
           hjust=0,
           vjust=1,
           label="...but is typically\nmuch less smooth ",
           size=2.5,
           colour="darkred") +
  theme_cowplot() +
  theme_no_y() +
  theme(plot.subtitle = element_text(hjust=0.5))
```

```{r,fig.width=10}
selected_samples<-sort(sample(n_samples,9))

ybars<-samples %>%
  select(all_of(selected_samples)) %>%
  pivot_longer(1:9,names_to="sample",values_to="mass") %>%
  group_by(sample) %>%
  summarise(ybar=mean(mass),s=sd(mass))
  
 
  samples %>%
  select(all_of(selected_samples)) %>%
  pivot_longer(1:9,names_to="sample",values_to="mass") %>%
  ggplot(aes(x=mass)) +
  geom_histogram(binwidth=5,fill=fill_colour1,colour=line_colour) +
  geom_function(fun=myfun,args=list(mean=mu,sd=sigma,N=sample_size,binwidth=5),colour=func_colour) +
  scale_x_continuous(limits=c(lower_xlim,upper_xlim)) +
  scale_y_continuous(breaks=c(0,10,20)) +
  labs(x='Weight(kg)', y='Frequency') +
  geom_segment(data=ybars,aes(x=ybar,y=0,xend=ybar,yend=17),colour="darkred",linetype="dashed")  +
  annotate("text", x = 95, y = 15, label = "italic(bar(y))", parse=TRUE,size=4) +
  geom_text(x = 100, y = 15, aes(label = paste(" = ",round(ybar,1))), data = ybars,size=4,hjust=0) +
  annotate("text", x = 95, y = 11, label = "italic(s)", parse=TRUE,size=4) +
  geom_text(x = 100, y = 11, aes(label = paste(" = ",round(s,1))), data = ybars,size=4,hjust=0) +
  facet_wrap(~sample,nrow=3) +
  theme_cowplot() +
  theme(axis.line.y = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks.y = element_blank()
        )+
  theme(strip.background = element_blank())
```

Notice how  all these sample distributions have _roughly_ the form of a normal distribution but that each one is in detail different from the others. This is the reality of sampling from a population - every sample will be different - but not _completely_ different. All those shown have roughly the same mean, shown by the dashed line, roughly the same standard deviation and roughly the same shape.

Note too that these samples are drawn from a population (we happen to know, because we created it!) whose mean value $\mu$ is 145 and for which the standard devation $\sigma$ is 15. In an actual study, we would have taken, most likely, just one sample, which could have been any of those you see above. The mean $\bar{y}$ and standard deviation $s$ of that sample would have been our best estimate of $\mu$ and $\sigma$.
```{r}
# sampling distribution - the distribution of the means of many samples drawn from a population.
sampling_dist<-
  sample_means %>%
  ggplot(aes(x=means)) +
  geom_histogram(binwidth=0.5,fill=fill_colour1,colour=line_colour,alpha=0.2) +
  geom_function(fun=myfun,args=list(mean=mu,sd=sigma/sqrt(sample_size),N=n_samples,binwidth=0.5),colour=func_colour) +
  scale_x_continuous(limits=c(lower_xlim,upper_xlim)) 
  labs(x='Weight(kg)',
       y='Frequency',
       subtitle="Sampling distribution") +
  annotate("text",
           x=89,y=29.2,
           hjust=0,
           vjust=0,
           label="This is much narrower\nthan the single sample\ndistribution ",
           size=2.5,
           colour="darkred") +
  annotate("text",
           x=152,y=29.2,
           hjust=0,
           vjust=0,
           label="The true mean and the\nmean of our one sample\nare somewhere in there ",
           size=2.5,
           colour="darkred") +
  theme_cowplot() +
  theme_no_y() +
  theme( plot.subtitle = element_text(hjust=0.5))
```

Below we contrast histograms of the population, a single sample of size 100 drawn from the population, and the so-called sampling distribution. That is, the distribution of the means of many samples of size 100 drawn from the population. Of these, the middle one, that of a single sample, is the only one we could get in practice.

```{r,fig.height=3}
# relation between the population distribution, the distribution of a single sample from that population, and the sampling
# distribution ie what you would get if you plotted the distribution of the means of many such samples.
grid.arrange(population_dist,single_sample_dist,sampling_dist,nrow=1)
```

In this case, the weights of the population are very close to being normally distributed. The mean is 145 kg and the standard deviation is 15 kg. You can see that the whole population has a weight within two or three standard deviations of the mean. In practice, we do not usually know either that the parameter of interest, in this case weight, definitely is normally distributed, or the mean and standard deviation of that distribution.

The weights of one sample of size 100 drawn from the population are also approximately normally distributed with a mean and standard deviation approximately equal to the that of the population. In practice, we might often only have only this one sample, so these would be our best estimates of the population mean and standard deviation and our judgement as to whether the population was normally distributed would be based on this one sample distribution alone. With small samples, it can often be hard to tell, just by looking at this histogram, whether the data have been drawn from a population that is normally distributed.

(In practice, we might also use other considerations - such as whether the data were a simple random sample and whether there were no outliers, and so on.)

The __sampling distribution__ is in practice a hypothetical distribution, since we cannot normally take many samples, each here of size 100, find the mean of each and plot the distribution of these. But if we could, this is what we would get. The mean of the one sample that we actually got is somewhere within this distribution and the true mean of the population is at the centre of it. A very interesting and useful thing about this distribution is that it will very likely be normally distributed, even if the population distribution was not, provided the sample size is large enough, and it is narrower than the population distribution. The larger the sample size, the narrower it is. These are handy facts, since they together mean that its width gives us an idea of the precision of our sample mean as an estimate of the the true mean. 

Some facts of interest about this distribution are:

a) it is normally distributed (and, if the sample sizes are large enough and the samples independent of each other, it probably would be even if the underlying distribution of the population were not a normal distribution.  

b) its mean is the true mean $\mu$ of the population.  

c) its standard deviation is narrower than that of the population as a whole or of one sample. If the standard deviation of the population is $\sigma$, where $\sigma = 15$kg in this case, and the samples each had size _n_, where _n_=100 in this case, then the standard deviation of this sampling distribution is $\frac{\sigma}{\sqrt{n}}$. So in this case, the standard deviation of this distribution is 1/10th that of the underlying population.  

d) if our sample size had been bigger, the sampling distribution would have been even narrower and so our estimate of the true mean would have been more precise. That is the benefit of having a bigger sample size.

Now, here is the really interesting thing about this distribution. It tells us about the precision of our estimate $\bar{y}$ that we got from our one sample of 100 seals of the true population mean $\mu$. Look at that sampling distribution. The true mean is somewhere in there, as is our sample mean. So whatever this value $\bar{y}$ is that we got from our sample, we know it is within the width of this distribution of the true mean. And how wide is this distribution? Well, since it reliably has the shape of a normal distribution, we know the answer to that. Roughly 95% of the values on this distribution are within two of its standard errors of the middle value $\mu$. This standard error, remember, is  $\frac{\sigma}{\sqrt{n}}$, where $\sigma$ is the population standard deviation, our best estimate of which is the standard deviation $s$ of our sample. Our sample mean $\bar{y}$  is our best estimate of this middle value, so we end up being able to say something like the following:

$$
\text{...the true mean = }\bar{y}{\text{ (our sample mean)}}\pm 2\times \frac{s{\text{ (our sample standard deviation)}}}{\sqrt{n}}
$$

We would call this range the __95% confidence interval__ for the thing we wanted to measure - in this case, the mean weight of adult female grey seals in the population of them around the south west of England.

What we mean by this is that if we repeatedly took a sample of 100 seals from the population and constructed the confidence interval for the mean in this way, then the true value would be within the interval 95% of the time.

Let us explore confidence intervals in more detail...

### Confidence intervals: a way of precisely representing uncertainty

We know that our estimate $\bar{y}$ of the population mean $\mu$ comes from the distribution of all possible $\bar{y}$ that are distributed around $\mu$ with a variance of $\frac{\sigma^2}{n}$, and thus a standard deviation of $\frac{\sigma}{\sqrt{n}}$. Let us now find the __confidence interval__ from our data. This is the range of possible values for the true population mean (which we don't know, remember) that cannot be rejected at the 5% significance level.

Parameters that have been estimated with great confidence will have a narrow confidence interval associated with them, while parameters about which we have less information will have a wide confidence interval.

From the properties of the standard normal distribution, we know that 95% of all such $\bar{y}$ will lie within 1.96 standard deviations of $\mu$, where the relevant standard deviation is that of the sampling distribution - the distribution of $\bar{y}$. That means that 5% will not!

This is illustrated below, where, for example, we show the true mean weight $\mu$ of adult female grey seals in south west England as a dotted line and either side of that, estimates of that obtained as the means from 20 samples, each of 100 seals, with their corresponding 95% confidence intervals. Note how nearly all of these confidence intervals do capture the true mean, but that one (in this case) does not.


```{r this_chunk,out.width="70%"}
# Graphic to show how often the CI captures the true value of a quantity
# re-coded from a great plot in OpenIntro. Theirs was in base R, this uses ggplot.
# there is another like this in Gelman et al

set.seed(876543212)
alpha<-0.05
trials<-20

estimators<-tibble(xs=rnorm(trials),ys=1:trials) %>%
  mutate(lowers=xs-abs(qnorm(alpha/2)),
         uppers=xs+abs(qnorm(alpha/2)),
         colours=ifelse((lowers>0 | uppers<0),"outside","inside"),
         linewidths=ifelse((lowers>0 | uppers<0),"thick","thin"))

estimators %>%
  ggplot(aes(x=xs,y=ys,colour=colours,size=linewidths)) +
  geom_point(size=5) +
  geom_linerange(aes(xmin = lowers, xmax = uppers)) +    
  scale_colour_manual(values=c(inside=point_colour,outside=error_colour)) +
  scale_size_manual(values=c(thick=2,thin=1)) +
  geom_vline(xintercept=0,linetype="dashed") +
  scale_x_continuous(limits=c(-6,6),
                     breaks=seq(-3,3),
                     labels=expression(mu-3*sigma,mu-2*sigma,mu-sigma,mu,mu+sigma,mu+2*sigma,mu+3*sigma)) +
  theme_cowplot() +
  theme_no_y() +
  theme(legend.position="none") +
  theme(axis.title.x=element_blank())
```


Hence we can say that, for 96% of the time:

$$
\mu-2\frac{\sigma}{\sqrt{n}} \lt \bar{y} \lt \mu+2\frac{\sigma}{\sqrt{n}}
$$

In practice, by convention, we are interested in a confidence level of 95% rather than 96%. This changes the 2 in the above formula to 1.96 - the confidence level is slightly lower, so the confidence interval is slightly less wide. Further, we would rather instead state a confidence interval for $\mu$ in terms of $\bar{y}$, rather than as above, so we rejig the last equation to give: 

$$
\bar{y}-1.96\frac{\sigma}{\sqrt{n}} \lt \mu \lt \bar{y}+1.96\frac{\sigma}{\sqrt{n}}
$$

This is now our 95% confidence interval for data drawn from a normally distributed population: the range of values that the true mean $\mu$ could take and be consistent with the data at the 95% level.

But there is a hitch...

### The big hitch with confidence intervals - why we use a $t$-distribution

The trouble with the previous expression, as a way of stating the confidence interval for a parameter such as the mean of some measure of a population, is that it requires that we know $\sigma$, the true standard deviation of of the population, and we don't know it exactly. All we have is an estimate of it, ie  $s$, the standard deviation of the sample. So there is some uncertainty in our knowledge of $\sigma$, just as there is in our knowledge of $\mu$ and this results in our 95% confidence interval for $\mu$ being somewhat wider than the value given above. 

The way this extra uncertainty can be accommodated is by modelling our data not by a normal distribution, but by a ___t___-**distribution**. This is similar to a normal distribution in that it is symmetrical, but it is lower and wider, with heavier tails on either side - which means that extreme values are more likely than for a normal. It is characterised by a centre, a scale and a _degrees of freedom_ parameter _df_ that can range from 1 to $\infty$ and which is one less than the number of data points in the sample: _df_ =*n*-1. The precise shape of the _t_-distribution depends on _df_. For small _df_ _t_ distributions have very heavy tails, but as the sample size increases and _df_ rises, so the _t_-distribution becomes taller and narrower and more and more like a normal distribution, until, for _df_ greater than 30 or so, the two are more or less indistinguishable. This reflects the fact that, the more data points we have, the more precise our estimate _s_ becomes of the population standard deviation $\sigma$.

This is illustrated below, where we see _t_-distributions for _df_ = 1, 3, 10 and 30 against a standard normal distribution.

```{r}
# how a  t-distribution relates to a normal, and how it changes with degrees of freedom

xvals<-seq(-4,4,0.01)
xs<-rep(seq(-4,4,0.01),4)
nreps<-length(xs)/4
ys<-c(dt(xvals,1),dt(xvals,3),dt(xvals,10),dt(xvals,30))
dfs<-c(rep(1,nreps),rep(3,nreps),rep(10,nreps),rep(30,nreps))

t_colour=COL["red","full"]

p<-tibble(x=xs,y=ys,df=as.factor(dfs)) %>%
  ggplot(aes(x=x,y=y,colour=df)) +
  geom_line() +
  geom_line(data=tibble(x=xvals,y=dnorm(xvals),df=rep("1",nreps)),aes(x=x,y=y),colour=func_colour) +
  theme_cowplot() +
  theme_no_y() +
  theme(legend.position="none")


p1<- p + scale_colour_manual(values=c("1"=t_colour,"3"="gray60","10"="gray40","30"="gray20")) +
  annotate("text",x=-0.9,y=0.4,hjust=1,label="Normal",colour=func_colour) +
  annotate("text",x=2,y=0.3,label="italic(df) == 1",colour= t_colour, parse=TRUE) +
  geom_segment(x=-0.9,y=0.39,xend=-0.4,yend=dnorm(-0.4),colour=func_colour, arrow=arrow(length = unit(0.2, "cm"),type="closed"))
p2<- p + scale_colour_manual(values=c("1"="gray80","3"=t_colour,"10"="gray40","30"="gray20")) +
  annotate("text",x=2,y=0.3,label="italic(df) == 3",colour= t_colour,parse=TRUE)
p3<- p + scale_colour_manual(values=c("1"="gray80","3"="gray60","10"=t_colour,"30"="gray20")) +
  annotate("text",x=2,y=0.3,label="italic(df) == 10",colour= t_colour, parse=TRUE)
p4<- p + scale_colour_manual(values=c("1"="gray80","3"="gray60","10"="gray40","30"=t_colour)) +
  annotate("text",x=2,y=0.3,label="italic(df) == 30",colour= t_colour,parse=TRUE)

grid.arrange(p1,p2,p3,p4,nrow=2)
```


To calculate the 95% confidence interval now we need to know how many standard deviations of the _t_-distribution we need to go either side of the mean in order to encompass 95% of the population. We call this the __critical t-value__ $t_\text{crit}$. For a normal distribution, remember, we had to go 1.96 standard deviations either side in order to do this. For a _t_-distribution, how far we need to go will depend on the degrees of freedom _df_. For a low value of _df_ the distribution has fatter tails so we need to go further out, but we need go less far as _df_ increases and the _t_-distribution becomes narrower until, when _df_ = 30 or so, we need only go as far as we would for a normal distribution, ie 1.96 standard deviations.

This is the effect of having a small sample: for such a sample our estimate of the true mean is less precise than if we had a larger sample, so the confidence interval, the range of values in which we are (say) 95% confident that the true value lies, is correspondingly wider.

For _df_ = 10, we find that $t_\text{crit}$ = 2.228

So, now, for small samples, we would write our  confidence interval as 

$$
\bar{y}-t_\text{crit}\frac{s}{\sqrt{n}} \lt \mu \lt \bar{y}+t_\text{crit}\frac{s}{\sqrt{n}}
$$

or, put another way,

$$
\mu= \text{estimate}\pm t_\text{crit}\times\text{standard error of the estimate}
$$
where the estimate is the mean of our sample, _s_ is the standard deviation of the sample, _n_ is the sample size and, for a 95% confidence interval and _df_ = 10, $t_\text{crit}$ = 2.228. For other confidence levels or other values of _df_, $t_\text{crit}$ would have a different value.

#### Pros and cons of using the _t_-distribution.

The _t_-distribution is widely used as a way of calculating confidence intervals for population parameters from sample estimates. It can be used when the sample size is small, whereas the normal distribution cannot, but it can also be used when the sample size is large, which is really handy. However, it is only valid to use it when the sample comprises independent observations that have been drawn from a population that is normally distributed, and this is not always easy to tell for small samples, just when we would really like to use it.

For example the figures below show histograms of four samples, each of size 10, all drawn from the same normally distributed population. Would you be able to tell, from looking at these histograms, that this was the case?

```{r,fig.height=2}
# histograms of small samples, drawn from a normally distributed population

set.seed(6756)
df_small_samples<-tibble(dataset=c(rep("A",10),rep("B",10),rep("C",10),rep("D",10)),data=c(rnorm(10,10,2),rnorm(10,10,2),rnorm(10,10,2),rnorm(10,10,2)))

df_small_samples %>%
  ggplot(aes(x=data)) +
  geom_histogram(binwidth=1,fill=fill_colour1,colour=line_colour) +
  scale_x_continuous(limits=c(7,13),
                     breaks=seq(7,13),
                     labels=c("","","",expression(mu),"","","")) +
  facet_wrap(~dataset,nrow=1) +
  theme_cowplot() +
  theme_no_y() +
  theme(axis.title.x=element_blank()) +
  theme(strip.background = element_blank())
```
For such small samples, qq-plots are a better visual way to assess normality. Here are qq-plots for the same four samples.

```{r,fig.height=2}
# qqplots of small samples

df_small_samples %>%
  ggplot(aes(sample=data)) +
  geom_qq(colour=point_colour) +
  geom_qq_line(colour=line_colour) +
  facet_wrap(~dataset,nrow=1) +
  theme_cowplot() +
  theme(axis.title.y=element_blank(),
        axis.text.y=element_blank()
        ) +
  theme(axis.title.x=element_blank(),
        axis.text.x=element_blank()
        ) +
  theme(strip.background = element_blank()) 
```


### Hypothesis testing

Here we lay out the concept of a null hypothesis and the method of testing such a hypothesis. We suppose that a sample mean and variance have been calculated, and that this information has been used to calculate a confidence interval. We can use this same information to test a hypothesis.

Suppose our sample was a set of 30 differences between two groups, for example the difference in test scores of a group before and after taking a statistics course. If there was no improvement over the duration of the course, then the mean difference should be zero. If the difference is defined as _score after_ - _score before_ then it is to be hoped that the mean difference is positive. However if the course actually confused the students then the difference could be negative.

To start with, we construct a __null hypothesis__. This normally expresses the conservative, 'nothing going on' scenario and states that no effect is expected, but it would be equally valid to state that the true mean takes some non-zero value.

On this case:

$$
\text{H}_0\text{: There is no difference between the scores, }\mu=0
$$
The alternative is that there is a difference. Normally, we would not state the direction of this difference, so the alternative hypothesis is phrased as:

$$
\text{H}_\text{A}\text{: }\mu\neq0
$$
The main principle of a hypothesis test is that we assume the null hypothesis is true and do not reject it unless there is convincing evidence that it is not true. In that sense it is like a classic court process, in which a defendant is assumed innocent  and will be acquitted unless we find convincing evidence to the contrary.

Note that both the null and alternate hypotheses are phrased in terms of population parameters, since it is the populatiom that we want to know about. The sample that we have drawn from it is just our window onto that. The sample mean $\bar{y}$ will almost certainly not be zero, and even if it were it would not mean that the true mean $\mu$, the mean of the population, is zero.

So what we do is assume that the null hypothesis is true and calculate the probability, given this, that we would have got the data we got, or more extreme data. By convention, if this probability falls below 0.05 we reject our assumption of $\text{H}_0$ being correct. This means that if the null hypothesis is true, there is a probability of 0.05 that we will reject it when we should not. We call this a __Type 1__ error.

```{r,fig.height=3}
df<-29
t_crit<-qt(0.975,df)

p_base<-ggplot(NULL, ) +
  geom_segment(aes(x=-6,y =0,xend=6,yend=0)) +
  stat_function(fun = dt,
                args=list(df=df),
                geom = "line",
                xlim = c(-6, 6)) +
  theme_cowplot() +
  theme_no_axes()

p<-p_base +
  annotate("text",label="0",x=0,y = -.013, size = 5, vjust=1) +
  annotate("text",label=bquote(bar(italic(y))~"?"),x=0.8,y =-0.08,size = 4, vjust=1, colour = "darkred") +
  annotate("text",label=bquote(bar(italic(y))~"?"),x=3,y =-0.08,size = 4, vjust=1,colour = "darkred") +
  annotate("text",label=bquote(-italic(t)[crit]~frac(italic(s),sqrt(italic(n)))),x=-t_crit,y =-0.013,size = 4, vjust=1) +
  annotate("text",label=bquote(+italic(t)[crit]~frac(italic(s),sqrt(italic(n)))),x=+t_crit,y =-0.013,size = 4, vjust=1) +
  geom_segment(aes(x=0.8,y =-0.07,xend=0.8,yend=0),
               arrow = arrow(length = unit(0.2, "cm")),colour="darkred",type="closed") +
  geom_segment(aes(x=3,y =-0.07,xend=3,yend=0),
               arrow = arrow(length = unit(0.2, "cm")),colour="darkred",type="closed") +
  geom_segment(aes(x=-t_crit,y =0,xend=-t_crit,yend=dnorm(-t_crit)),linetype="dashed") +
  geom_segment(aes(x=t_crit,y =0,xend=t_crit,yend=dnorm(t_crit)),linetype="dashed") +
  coord_cartesian(clip='off')



# now add ticks to the x-axis
ticks_data = data.frame(
    x = seq(-6,6,2),
    xend = seq(-6,6,2), 
    y = rep(0,7),
    yend = rep(-0.01,7)
)
p <- p + geom_segment(data=ticks_data, aes(x = x, y = y, xend = xend, yend = yend))

p <- p +
    stat_function(fun = dt,
                args=list(df=df),
                geom = "area",
                fill = fill_colour1,
                xlim = c(-6, -t_crit)) +
    stat_function(fun = dt,
                args=list(df=df),
                geom = "area",
                fill = fill_colour1,
                xlim = c(t_crit, 6)) 
p
```

The figure above shows the distribution of our random variable (the mean difference between individual students' scores before and after a course of study) under the null hypothesis. It is centred at zero, in this case. Our value of $\bar{y}$, we suppose, is one datapoint from this distribution. In a hypothesis test we ask how likely it is that this could really be the case. 

THe answer depends on how far from the centre of the distribution our value of $\bar{y}$ lies. If it is close to 0 then it may well have come from this distribution, but if it is far from it, then we conclude that it is unlikely to have done so.

When measuring the distance from 0, it is not the absolute distance that matters, but the number of standard errors of the sampling distribution, which we find by dividing the absolute distance by this standard error. In terms of this unit, this distance is known as the __*t*-statistic__:

$$
t_\text{s}=\frac{\bar{y}-0}{\frac{s}{\sqrt{n}}}
$$
Let us remember that the area under a probability distribution curve between two values is the probability that the random variable described by that pdf takes a value in that range. The probability that the mean of our sample could have been as far or further from 0 than it actually is is equal to the area under the distribution curve beyond that distance from 0, including both sides. We compare this with a critical probability, called the __significance level__ of the test, _which we choose_ but which is conventionally set at 0.05 ie 5% of the total area under the curve. The number of standard errors from 0 at which this happens is a critical value of the *t*-statistic known as $t_\text{crit}$. Its value depends on the significance level we choose and on the degrees of freedom ie the sample size.

In the end, if our _*t*-statistic_ is greater than the critical _t_-value then the probability that we could have got such a value of $\bar{y}$ from a distribution centered on 0 is less than 0.05. We call this probability a __*p*-value__, and so, if $p<0.05$ we decide that the strength of the evidence is such as to allow us to _reject the null hypothesis_.

In summary, the _p_-value is the probability of obtaining the the data you got, and thus the _t_-statistic you got, if the null hypothresis were true.

#### One sample _t_-test

Let us return to our class of students. Here is a histogram of the changes in their test scores following their course of study. We shall call this change DIFF:

```{r}

diffs<-c(-0.5,0,0.5,1.0,1.5,2.0,2.5)
freqs<-c(3,4,10,5,1,5,2)
df<-tibble(diff=diffs,freq=freqs)

df<-read_csv(here("data","Grafen_Hales_data","basics_DIFF.csv"))

df %>%
  ggplot(aes(x=DIFF)) +
  geom_histogram(binwidth=0.5,colour=line_colour,fill=fill_colour1) +
  scale_x_continuous(breaks=seq(-0.5,2.5,0.5)) +
  scale_y_continuous(breaks=seq(0,12,2)) +
  labs(x="DIFF = Score after - Score before",y="Frequency") +
  theme_cowplot()
```

We see that some students _did_ score worse in the test following the course than in the test preceding it, but a majority have improved their score. It seems from this chart the the course of study has helped the students, on the whole, but to check that this improvement we carry out a test.

The mean value $\bar{y}$ of DIFF is 0.862 and the standard deviation _s_ of DIFF is 0.838. The number of students is _n_ is 30, so the degrees of freedom _df_ is 29. The standard error in the mean is $s/\sqrt{n} = 0.153$. Hence the _t_-statistic, the number of standard errors of the mean from the null prediction of 0 (in this case) is 0.862 / 0.153 = 5.64.

Look at the plot of a _t_-distribution for 30 degrees of the freedom (that for 29 degrees of freedom will be very similar to that) in the figure above. What proportion of the area under the curve, do you think, is more than 5.64 standard errors away from 0? Most of it it, some of it, or practically none of it?

You can see that this distance is so far way that there is effectively no area under the curve that is that far or further from 0. We interpret this as meaning there is almost zero probability that we would have got this data if the null hypothesis were true. This probability is what we call a _p_-value. In particular, the _p_-value for this one sample _t_-test is well below 0.05, in fact _p_ < 0.001 so we can confidently reject the null hypothesis and conclude that in general, students' score did improve following their course of study. (We infer the direction of change from the fact that the mean difference is positive, and also from the range of values contained within the confidence interval.)

If we were to do this test in R, this is the output we would get:

```{r}
t.test(df$DIFF)
```

#### General procedure for a hypothesis test

The procedure outlined above can be generalised to include a population mean of any value, not just zero, and to testing other parameters estimated from samples against hypothesised values of those parameters for the population.

The procedure can be broken down into these steps:

1. Define the null and alternate hypotheses in terms of population parameters.
2. Plot the data, most likely using a box plot or a histogram.
3. Calculate the sample estimate $\bar{y}$ of the population parameter.
4. Calculate the standard error $s/\sqrt{n}$ of this estimate.
5. Determine whether it is appropriate to use a _t_-test
6. Calculate the _t_-statistic 
7. Calculate the _p_-value for this _t_-statistic.
8. Based on the _p_-value, reject or fail to reject the null hypothesis.

###  Comparing two means

#### A two-sample test for a difference

Suppose we hypothesise that male and female squirrels differ in body mass. 50 squirrels of each sex are measured, and the body masses of each are recorded. 

Histograms and qq-plots of the data are shown below:

```{r}
path<-here("data","Grafen_Hales_data","basics_SQUIRREL.csv")
squirrels<-read_csv(path) %>%
  pivot_longer(1:2,names_to="sex",values_to="mass") %>%
  mutate(log_mass=log(mass))
```
  
```{r}
sq_histograms<-
  squirrels %>%
  ggplot(aes(x=mass)) +
  geom_histogram(binwidth=0.1,fill=fill_colour1,colour=line_colour) +
  scale_x_continuous(breaks=seq(0.3,1.1,0.2)) +
  labs(x="Mass (kg)",y="Frequency") +
  facet_wrap(~sex,nrow=1) +
  theme_cowplot() +
  theme_no_y() +
  theme(strip.background = element_blank())
```

```{r}
sq_qqplots<-
  squirrels %>%
  ggplot(aes(sample=mass)) +
  geom_qq(colour=point_colour) +
  geom_qq_line(colour=line_colour) +
  facet_wrap(~sex,nrow=1) +
  theme_cowplot() +
  theme(axis.title.y=element_blank(),
        axis.text.y=element_blank()
        ) +
  theme(axis.title.x=element_blank(),
        axis.text.x=element_blank()
        ) +
theme(strip.background = element_blank(),
      strip.text=element_blank())
```
```{r}
grid.arrange(sq_histograms,sq_qqplots)
```

These histograms, especially for males, do not look very symmetrical. Both distributions are skewed to the right. The effect of this is that the few squirrels with particularly large body masses will greatly increase the means of the samples and in doing so suggest that the whole body mass distribution is greater than it is in reality. This is reflected in the qqplots for both sexes, which are distinctly curved. The data are clearly not normally distributed.

As it stands, we cannot use a _t_-test to decide whether the data are drawn from the same distribution. We can instead either use a _non-parameteric_ test for a difference, such as a Mann-Whitney test, that does not demand that the data follow a particular distribution, or we can attempt one of a number of possible _transformations_ of the data, such as taking the natural log of the body mass, in the hope of achieving a more symmetric distribution.

we show the result of doing this below:

```{r}
sq_log_histograms<-
  squirrels %>%
  ggplot(aes(x=log_mass)) +
  geom_histogram(binwidth=0.1,fill=fill_colour1,colour=line_colour) +
  scale_x_continuous(breaks=seq(0.3,1.1,0.2)) +
  labs(x="log (mass)",y="Frequency") +
  facet_wrap(~sex,nrow=1) +
  theme_cowplot() +
  theme_no_y() +
  theme(strip.background = element_blank())

sq_log_qqplots<-
  squirrels %>%
  ggplot(aes(sample=log_mass)) +
  geom_qq(colour=point_colour) +
  geom_qq_line(colour=line_colour) +
  facet_wrap(~sex,nrow=1) +
  theme_cowplot() +
  theme(axis.title.y=element_blank(),
        axis.text.y=element_blank()
        ) +
  theme(axis.title.x=element_blank(),
        axis.text.x=element_blank()
        ) +
  theme(strip.background = element_blank(),
        strip.text=element_blank())
```

```{r}
grid.arrange(sq_log_histograms,sq_log_qqplots)
```
That's much better.
$$
\begin{align*}
\text{H}_0&:\quad\mu_\text{A}=\mu_\text{B}\quad\text{or}\quad\mu_\text{A}-\mu_\text{B}=0\\
\text{H}_0&:\quad\mu_\text{A}\neq\mu_\text{B}
\end{align*}
$$
```{r}
males<-filter(squirrels)
```

```{r}
#### Why we do it

#### How we do it

#### Why would we want a scheme where we try to reject or hold on to a null hypothesis if we never believed this in the first place?
```

### Size effects vs hypothesis testing.

```{block, type='warning-box'}
**Red boxes**

These contain a __warning__ or flag a common __gotcha__ that may trip you up. They highlight potential pitfalls and show you how to avoid them. You will avoid future mistakes if pay close attention to these.
```
